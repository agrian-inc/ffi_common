//! # `ffi_derive`
//!
//! A library for deriving a C foreign function interface (FFI) from type definitions in Rust.
//!
//! ## Design:
//!
//! We want to be able to share common resource type definitions across all platforms, which will
//! provide a foundation for sharing more complex code. We can do that in Rust, but it requires
//! duplicating type definitions and mananging memory in a wrapper for each Rust FFI library, which
//! is extremely time consuming and can be tricky to get right. This library aims to address those
//! problems by making it trivial to derive a safe native interface for other languages from a
//! native rust interface.
//!
//! We do this by:
//! 1. Generating an FFI module for every `ffi_derive` type (that's the main job of this crate).
//! 1. Running [`cbindgen`](https://github.com/eqrion/cbindgen) to generate a C interface for all of
//! those types.
//!   * This currently has to be done in the client library. We should eventually be able to produce
//!   the necessary `build.rs` and `lib.rs` for FFI crates.
//! 1. Generating a native interface in one of the supported languages with `ffi_consumer`. This
//! wraps the C headers generated by the previous step in native types for the specified language.
//!
//! ### Additional design considerations:
//! * Using or defining a type that happens to have a derived FFI must not be any different from
//! using or defining a non-FFI type. We want it to be easy to make any Rust type provide an FFI
//! module, with minimal design considerations for that use case.
//! * The C interface generated by this library should **not** be used directly. The generated code
//! in the FFI modules relies on invariants that we uphold in our generated native wrappers, which
//! lets us simplify and optimize (for example, we don't have to worry about non-optional types
//! coming in as `std::ptr::null`, or who initialized some piece of memory, because we control both
//! sides of the C interface). We can't enforce that if you use the C interface directly, so you
//! may run into `panic`s, UB, etc.
//!
//! ### Alternatives
//! There are many ways to provide a Rust FFI, some of which may be more appropriate in certain
//! contexts.
//! 1. A [simple C FFI](https://bitbucket.org/agrian/libcompliance/src/develop/ffi/) can use JSON
//! (de)serialization to exchange data, but this requires implementing any necessary types and
//! (de)serialization in every foreign client, and the overhead for converting all data to/from JSON
//! isn't trivial if you want to use Rust in a front-end application.
//! 1. [Manually wrapping native types](https://bitbucket.org/agrian/wise_units/src/develop/) is
//! another option, with a somewhat cleaner interface, but this ends up with _even more_
//! duplication, and has more complex memory management to worry about.
//! 1. There are [other options](https://docs.rs/ffi-support/0.4.2/ffi_support/) that provide
//! utilities for making an FFI safer, but definitions still need to be duplicated and memory still
//! needs to be managed individually in wrapping libraries.
//!
//! ## Supported types:
//! 1. `String`.
//! 1. `Uuid`.
//! 1. Numeric primitives (`u8` through `f64`).
//! 1. Custom `repr(C)` types.
//! 1. Custom non-`repr(C)` types.
//! 1. Typealiases over any of the above.
//! 1. A few specific generics:
//!   1. `Option<T>` where `T` is any supported type (but not nested `Option<Option<T>>`).
//!   1. `Vec<T>` where `T` is any supported type (but not nested `Vec<Vec<T>>`).
//!   1. `Option<Vec<T>>` where `T` is any supported type (but no additional nesting).
//!
//! ## Using `ffi_derive`
//!
//! With simple enums or structs that can be marked `repr(C)`, you can do something like this, where
//! `cffi` is a feature that determines whether you're building for a C FFI (so that compiling for
//! other purposes isn't constrained to C's memory layout rules):
//! ```
//! #[cfg_attr(feature = "cffi", repr(C), no_mangle, derive(ffi_derive::FFI))]
//! pub enum NativeEnum {
//!     V1,
//!     V2,
//! }
//!
//! impl Default for NativeEnum {
//!     fn default() -> Self {
//!         Self::V1
//!     }
//! }
//! ```
//!
//! With more complicated structs (the primary focus of this library), you can similarly use a
//! feature to control when the type is built with `ffi_derive`.
//!
//! Typealiases are supported, with the caveat that you have to provide a path to the file(s) in
//! which any typealiases referenced in the definition of this type are defined (see
//! `ffi(alias_paths("src/ids.rs"))` in the example below; if `NativeStructId` was an alias over
//! `Uuid` defined in a file at that path (relative to the root of the crate), we'd figure out what
//! type to treat that field as for the purposes of FFI.)
//!
//! Custom types that are safe to use directly in FFI can be marked `ffi(raw)` (see `enum_variant`
//! in the example below).
//! ```ignore
//! #[cfg_attr(
//!     feature = "cffi",
//!     derive(ffi_derive::FFI),
//!     ffi(alias_paths("src/ids.rs"))
//! )]
//! #[derive(Clone, Debug)]
//! pub struct NativeStruct {
//!     pub a_native_struct_id: NativeStructId,
//!     pub a_string: String,
//!     pub an_f32: f32,
//!     pub a_datetime: NaiveDateTime,
//!     pub collection_of_ids: Vec<Uuid>,
//!     #[cfg_attr(feature = "cffi", ffi(raw))]
//!     pub enum_variant: NativeEnum,
//! }
//! ```
//!

#![warn(
    future_incompatible,
    missing_copy_implementations,
    nonstandard_style,
    trivial_casts,
    trivial_numeric_casts,
    unreachable_pub,
    unused_qualifications,
    unused_results,
    variant_size_differences,
    clippy::all,
    clippy::complexity,
    clippy::correctness,
    clippy::pedantic,
    clippy::perf,
    clippy::nursery,
    clippy::style
)]
#![forbid(missing_docs, unused_extern_crates, unused_imports)]

mod enum_ffi;
mod field_ffi;
mod parsing;
mod struct_ffi;

use heck::SnakeCase;
use proc_macro::TokenStream;
use quote::format_ident;
use syn::{Data, DeriveInput};

/// Derive an FFI for a native type definition.
#[proc_macro_derive(FFI, attributes(ffi))]
pub fn ffi_derive(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_ffi_macro(&ast)
}

fn impl_ffi_macro(ast: &DeriveInput) -> TokenStream {
    let type_name = &ast.ident;
    let module_name = format_ident!("{}_ffi", &type_name.to_string().to_snake_case());
    match &ast.data {
        Data::Struct(data) => {
            // Get the relative file paths from the attribute args, prefix them with the cargo
            // manifest dir, then build a hash map for resolving type aliases.
            let crate_root = std::env::var("CARGO_MANIFEST_DIR").expect(
                "Could not find `CARGO_MANIFEST_DIR` to look up aliases in `ffi_derive::impl_ffi_macro`.",
            );

            let struct_attributes = parsing::parse_struct_attributes(&ast.attrs);

            let paths: Vec<String> = struct_attributes.alias_paths
                .iter()
                .map(|path| format!("{}/{}", crate_root, path))
                .collect();
            let alias_map = parsing::type_alias_map(&paths);

            match struct_attributes.custom_path {
                Some(custom_module_path) => {
                    struct_ffi::build_custom(&module_name, &format!("{}/{}", crate_root, custom_module_path), type_name)
                }
                None => struct_ffi::build(&module_name, type_name, &data.fields, &alias_map)
            }
        }
        Data::Enum(_) => {
            if !parsing::is_repr_c(&ast.attrs) {
                panic!("Non-repr(C) enums are not supported.")
            }
            enum_ffi::build(&module_name, type_name)
        }
        Data::Union(_) => panic!("Unions are not supported"),
    }
    .into()
}
